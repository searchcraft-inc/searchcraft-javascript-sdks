{"file":"utils-dbb6302b.js","mappings":"SAAgB,iBAAiB,CAC/B,MAAuC;IAEvC,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;QAC9B,IAAI;YACF,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;SAC3B;QAAC,OAAO,KAAK,EAAE;YACd,OAAO,CAAC,KAAK,CAAC,8BAA8B,EAAE,MAAM,CAAC,CAAC;YACtD,OAAO,EAAE,CAAC;SACX;KACF;IACD,OAAO,MAAM,IAAI,EAAE,CAAC;AACtB,CAAC;SAEe,eAAe,CAC7B,4BAAoC;IAEpC,IAAI;QACF,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,4BAA4B,CAAC,CAAC;QAC5D,IACE,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC;YACzB,UAAU,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,OAAO,GAAG,KAAK,QAAQ,CAAC,EAClD;YACA,OAAO,UAAU,CAAC;SACnB;QACD,OAAO,CAAC,IAAI,CACV,2EAA2E,CAC5E,CAAC;QACF,OAAO,EAAE,CAAC;KACX;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,CAAC,KAAK,CAAC,6BAA6B,EAAE,KAAK,CAAC,CAAC;QACpD,OAAO,EAAE,CAAC;KACX;AACH,CAAC;SAEe,wBAAwB,CACtC,QAAyC,EACzC,IAAc;IAEd,MAAM,mBAAmB,GAAoC,EAAE,CAAC;IAChE,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG;QACf,mBAAmB,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;KAChD,CAAC,CAAC;IACH,OAAO,mBAAmB,CAAC;AAC7B,CAAC;SAEe,eAAe,CAC7B,MAA8C;IAE9C,IAAI;QACF,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;KAC/B;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,CAAC,KAAK,CAAC,2BAA2B,EAAE,KAAK,CAAC,CAAC;QAClD,OAAO,IAAI,CAAC;KACb;AACH,CAAC;SAEe,uBAAuB,CAAC,SAAiB;IACvD,MAAM,GAAG,GAAG,IAAI,IAAI,EAAE,CAAC;IACvB,MAAM,SAAS,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC;IACtC,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAC9B,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,SAAS,CAAC,OAAO,EAAE,IAAI,IAAI,CAC7C,CAAC;IAEF,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,GAAG,EAAE,CAAC,CAAC;IAC/C,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,EAAE,CAAC,CAAC;IACvC,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,EAAE,CAAC,CAAC;IACpC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC;IAErC,IAAI,OAAO,GAAG,EAAE,EAAE;QAChB,OAAO,GAAG,OAAO,OAAO,CAAC;KAC1B;IACD,IAAI,KAAK,GAAG,EAAE,EAAE;QACd,OAAO,GAAG,KAAK,OAAO,CAAC;KACxB;IACD,IAAI,IAAI,GAAG,GAAG,EAAE;QACd,OAAO,GAAG,IAAI,OAAO,CAAC;KACvB;IACD,OAAO,GAAG,KAAK,OAAO,CAAC;AACzB;;;;","names":[],"sources":["src/utils/utils.ts"],"sourcesContent":["export function parseCustomStyles(\n  styles: string | Record<string, string>,\n): Record<string, string> {\n  if (typeof styles === 'string') {\n    try {\n      return JSON.parse(styles);\n    } catch (error) {\n      console.error('Invalid customStyles format:', styles);\n      return {};\n    }\n  }\n  return styles || {};\n}\n\nexport function parseSearchKeys(\n  documentAttributesForDisplay: string,\n): string[] {\n  try {\n    const parsedKeys = JSON.parse(documentAttributesForDisplay);\n    if (\n      Array.isArray(parsedKeys) &&\n      parsedKeys.every((key) => typeof key === 'string')\n    ) {\n      return parsedKeys;\n    }\n    console.warn(\n      'searchKeys must be a JSON array of strings. Defaulting to an empty array.',\n    );\n    return [];\n  } catch (error) {\n    console.error('Failed to parse searchKeys:', error);\n    return [];\n  }\n}\n\nexport function extractDynamicProperties(\n  document: Record<string, string | number>,\n  keys: string[],\n) {\n  const extractedProperties: Record<string, string | number> = {};\n  keys.forEach((key) => {\n    extractedProperties[key] = document[key] || '';\n  });\n  return extractedProperties;\n}\n\nexport function serializeStyles(\n  styles: Record<string, Record<string, string>>,\n): string {\n  try {\n    return JSON.stringify(styles);\n  } catch (error) {\n    console.error('Error serializing styles:', error);\n    return '{}';\n  }\n}\n\nexport function getFormattedTimeFromNow(timestamp: string): string {\n  const now = new Date();\n  const inputTime = new Date(timestamp);\n  const diffInSeconds = Math.floor(\n    (now.getTime() - inputTime.getTime()) / 1000,\n  );\n\n  const minutes = Math.floor(diffInSeconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n  const years = Math.floor(days / 365);\n\n  if (minutes < 60) {\n    return `${minutes}m ago`;\n  }\n  if (hours < 24) {\n    return `${hours}h ago`;\n  }\n  if (days < 365) {\n    return `${days}d ago`;\n  }\n  return `${years}y ago`;\n}\n"],"version":3}